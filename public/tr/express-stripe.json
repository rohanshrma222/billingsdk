{
  "name": "express-stripe",
  "description": "Stripe template for Express.js",
  "framework": "express",
  "files": [
    {
      "target": "lib/stripe.ts",
      "type": "template",
      "content": "import Stripe from 'stripe';\n\nlet _stripe: Stripe | null = null;\nexport const getStripe = (): Stripe => {\n  const key = process.env.STRIPE_SECRET_KEY;\n  if(!key){\n    throw new Error(\"STRIPE_SECRET_KEY is not set\")\n  }\n  if (!_stripe) {\n    _stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {\n      \n    });\n  }\n  return _stripe;\n};\n\n\n\nlet stripe = getStripe();\n\n\nexport type Product = Stripe.Product;\nexport type Customer = Stripe.Customer;\nexport type Subscription = Stripe.Subscription;\nexport type PaymentIntent = Stripe.PaymentIntent;\n\n\nexport async function getProducts(): Promise<Product[]> {\n  try {\n    const { data } = await stripe.products.list({ limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching products', error);\n    throw new Error('Failed to fetch products');\n  }\n}\n\nexport async function getProduct(product_id: string): Promise<Product> {\n  try {\n    return await stripe.products.retrieve(product_id);\n  } catch (error) {\n    console.error('Error fetching product', error);\n    throw new Error('Failed to fetch product');\n  }\n}\n\n\nexport async function getCustomer(customer_id: string): Promise<Customer | Stripe.DeletedCustomer> {\n  try {\n    const customer = await stripe.customers.retrieve(customer_id);\n    \n    if ((customer as Stripe.DeletedCustomer).deleted) {\n      return customer as Stripe.DeletedCustomer;\n    }\n    return customer as Customer;\n  } catch (error) {\n    console.error('Error fetching customer', error);\n    throw new Error('Failed to fetch customer');\n  }\n}\n\nexport async function createCustomer(params: Stripe.CustomerCreateParams): Promise<Customer> {\n  try {\n    return await stripe.customers.create(params);\n  } catch (error) {\n    console.error('Error creating customer', error);\n    throw new Error('Failed to create customer');\n  }\n}\n\nexport async function updateCustomer(customer_id: string, params: Stripe.CustomerUpdateParams): Promise<Customer> {\n  try {\n    return await stripe.customers.update(customer_id, params);\n  } catch (error) {\n    console.error('Error updating customer', error);\n    throw new Error('Failed to update customer');\n  }\n}\n\n\nexport async function getCustomerSubscriptions(customer_id: string): Promise<Subscription[]> {\n  try {\n    const { data } = await stripe.subscriptions.list({ customer: customer_id });\n    return data;\n  } catch (error) {\n    console.error('Error fetching subscriptions', error);\n    throw new Error('Failed to fetch subscriptions');\n  }\n}\n\n\nexport async function getCustomerPayments(customer_id: string): Promise<PaymentIntent[]> {\n  try {\n    const { data } = await stripe.paymentIntents.list({ customer: customer_id, limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching payments', error);\n    throw new Error('Failed to fetch payments');\n  }\n}\n\n\nexport async function checkout(opts: {\n  price_id: string;\n  customer_id?: string;\n  success_url: string;\n  cancel_url: string;\n}): Promise<{ checkout_url: string }> {\n  try {\n    const session = await stripe.checkout.sessions.create({\n      mode: 'subscription',\n      line_items: [{ price: opts.price_id, quantity: 1 }],\n      customer: opts.customer_id ?? '',\n      success_url: opts.success_url,\n      cancel_url: opts.cancel_url,\n    });\n    return { checkout_url: session.url! };\n  } catch (error) {\n    console.error('Error creating checkout session', error);\n    throw new Error('Failed to create checkout session');\n  }\n}\n"
    },
    {
      "target": "routes/stripe/route.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { checkoutRouter } from './checkout';\nimport { customerRouter } from './customer';\nimport { paymentsRouter } from './payments';\nimport { productsRouter } from './products';\nimport { subscriptionsRouter } from './subscriptions';\nimport { webhookRouter } from './webhook';\n\nconst router = express.Router();\n\nrouter.use('/checkout', checkoutRouter);\nrouter.use('/customer', customerRouter);\nrouter.use('/payments', paymentsRouter);\nrouter.use('/products', productsRouter);\nrouter.use('/subscriptions', subscriptionsRouter);\nrouter.use('/webhook', webhookRouter);\n\nexport { router as stripeRouter };\n"
    },
    {
      "target": "routes/stripe/checkout.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { z } from 'zod';\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\nconst router = express.Router();\nconst stripe = getStripe();\n\n\nconst productCartItemSchema = z.object({\n  price_id: z.string().min(1, \"Price ID is required\"),\n  quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n});\n\nconst attachExistingCustomerSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst newCustomerSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n  create_new_customer: z.boolean().optional(),\n});\n\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\nconst checkoutSessionSchema = z.object({\n  productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n  customer: customerSchema.optional(),\n  success_url: z.string().url(\"Success URL must be a valid URL\"),\n  cancel_url: z.string().url(\"Cancel URL must be a valid URL\"),\n  metadata: z.record(z.string(), z.string()).optional(),\n});\n\n\nrouter.post('/', async (req, res) => {\n  try {\n    const validationResult = checkoutSessionSchema.safeParse(req.body);\n    if (!validationResult.success) {\n      return res.status(400).json({\n        error: \"Validation failed\",\n        details: validationResult.error.issues.map(issue => ({\n          field: issue.path.join('.'),\n          message: issue.message,\n        })),\n      });\n    }\n\n    const { productCart, customer, success_url, cancel_url, metadata } = validationResult.data;\n\n    let customerId: string | undefined;\n    if (customer && 'email' in customer) {\n      const stripeCustomer = await stripe.customers.create({\n        email: customer.email ?? \"\",\n        name: customer.name ?? \"\",\n        phone: customer.phone_number ?? \"\",\n      });\n      customerId = stripeCustomer.id;\n    } else if (customer && 'customer_id' in customer) {\n      customerId = customer.customer_id;\n    }\n\n    \n    const sessionParams: Stripe.Checkout.SessionCreateParams = {\n      payment_method_types: [\"card\"],\n      line_items: productCart.map(item => ({\n        price: item.price_id,\n        quantity: item.quantity,\n      })),\n      mode: \"payment\",\n      success_url: success_url + \"?session_id={CHECKOUT_SESSION_ID}\",\n      cancel_url: cancel_url,\n      \n      ...(metadata ? { metadata } : {}),\n    };\n\n    \n    if (customerId) {\n      sessionParams.customer = customerId;\n    }\n\n    const session = await stripe.checkout.sessions.create(sessionParams);\n\n    res.json({ url: session.url });\n  } catch (error) {\n    console.error('Stripe checkout error:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\nexport { router as checkoutRouter };\n"
    },
    {
      "target": "routes/stripe/customer.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { getStripe } from '../../lib/stripe';\nimport { z } from 'zod';\nimport type Stripe from 'stripe';\n\nconst router = express.Router();\nconst stripe = getStripe();\n\nconst customerCreateSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n});\n\nconst customerUpdateSchema = z.object({\n  email: z.string().email(\"Invalid email format\").optional(),\n  name: z.string().min(1, \"Name is required\").optional(),\n  phone_number: z.string().optional().nullable(),\n});\n\n\nrouter.get('/', async (req, res) => {\n  try {\n    const { customer_id } = req.query;\n    if (!customer_id || typeof customer_id !== 'string') {\n      return res.status(400).json({ error: 'customer_id is required' });\n    }\n\n    const customer = await stripe.customers.retrieve(customer_id);\n    res.json(customer);\n  } catch (error) {\n    console.error('Error fetching customer:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// POST /customer\nrouter.post('/', async (req, res) => {\n  try {\n    const validationResult = customerCreateSchema.safeParse(req.body);\n    if (!validationResult.success) {\n      return res.status(400).json({\n        error: \"Validation failed\",\n        details: validationResult.error.issues.map(issue => ({\n          field: issue.path.join('.'),\n          message: issue.message\n        }))\n      });\n    }\n\n    const customer = await stripe.customers.create({\n      email: validationResult.data.email,\n      name: validationResult.data.name,\n      phone: validationResult.data.phone_number ?? \"\",\n    });\n\n    res.json(customer);\n  } catch (error) {\n    console.error('Error creating customer:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n\nrouter.put('/', async (req, res) => {\n  try {\n    const { customer_id } = req.query;\n    if (!customer_id || typeof customer_id !== 'string') {\n      return res.status(400).json({ error: 'customer_id is required' });\n    }\n\n    const validationResult = customerUpdateSchema.safeParse(req.body);\n    if (!validationResult.success) {\n      return res.status(400).json({\n        error: \"Validation failed\",\n        details: validationResult.error.issues.map(issue => ({\n          field: issue.path.join('.'),\n          message: issue.message\n        }))\n      });\n    }\n\n    const updateData: Stripe.CustomerUpdateParams = {};\n    if (validationResult.data.email) updateData.email = validationResult.data.email;\n    if (validationResult.data.name) updateData.name = validationResult.data.name;\n    if (validationResult.data.phone_number) updateData.phone = validationResult.data.phone_number;\n\n    const customer = await stripe.customers.update(customer_id, updateData);\n    res.json(customer);\n  } catch (error) {\n    console.error('Error updating customer:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n\nrouter.get('/subscriptions', async (req, res) => {\n  try {\n    const { customer_id } = req.query;\n    if (!customer_id || typeof customer_id !== 'string') {\n      return res.status(400).json({ error: 'customer_id is required' });\n    }\n\n    const subscriptions = await stripe.subscriptions.list({\n      customer: customer_id,\n      limit: 100,\n    });\n\n    res.json(subscriptions.data);\n  } catch (error) {\n    console.error('Error fetching customer subscriptions:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n\nrouter.get('/payments', async (req, res) => {\n  try {\n    const { customer_id } = req.query;\n    if (!customer_id || typeof customer_id !== 'string') {\n      return res.status(400).json({ error: 'customer_id is required' });\n    }\n\n    const paymentIntents = await stripe.paymentIntents.list({\n      customer: customer_id,\n      limit: 100,\n    });\n\n    res.json(paymentIntents.data);\n  } catch (error) {\n    console.error('Error fetching customer payments:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\nexport { router as customerRouter };\n"
    },
    {
      "target": "routes/stripe/payments.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { getStripe } from '../../lib/stripe';\n\nconst stripe = getStripe()\nconst router = express.Router();\n\nrouter.get('/', async (req, res) => {\n    try {\n        const { payment_id } = req.query;\n\n        if (!payment_id || typeof payment_id !== 'string') {\n            return res.status(400).json({ error: 'payment_id is required' });\n        }\n\n        const payment = await stripe.paymentIntents.retrieve(payment_id);\n        res.json(payment);\n    } catch (error) {\n        console.error('Error fetching payment:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\nrouter.get('/list', async (req, res) => {\n    try {\n        const { customer_id, limit, starting_after } = req.query;\n\n        const params: any = {};\n        if (customer_id && typeof customer_id === 'string') {\n            params.customer_id = customer_id;\n        }\n        if (limit && typeof limit === 'string') {\n            params.limit = parseInt(limit);\n        }\n        if (starting_after && typeof starting_after === 'string') {\n            params.starting_after = starting_after;\n        }\n\n        const payments = await stripe.paymentIntents.list(params);\n        res.json(payments);\n    } catch (error) {\n        console.error('Error fetching payments list:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\nexport { router as paymentsRouter };\n"
    },
    {
      "target": "routes/stripe/products.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\nconst router = express.Router();\nconst stripe = getStripe();\n\n\nrouter.get('/', async (req, res) => {\n  try {\n    const { limit, starting_after } = req.query;\n\n    const params: Stripe.ProductListParams = {};\n    if (limit && typeof limit === 'string') {\n      const parsed = parseInt(limit, 10);\n      if (!isNaN(parsed)) params.limit = parsed;\n    }\n\n    if (starting_after && typeof starting_after === 'string') {\n      params.starting_after = starting_after;\n    }\n\n\n    const products = await stripe.products.list(params);\n    res.json(products.data); // this returns only product array\n  } catch (error) {\n    console.error('Error fetching products:', error);\n    res.status(500).json({ error: 'Internal server error', details: (error as Error).message });\n  }\n});\n\n\nrouter.get('/product', async (req, res) => {\n  try {\n    const { product_id } = req.query;\n\n    if (!product_id || typeof product_id !== 'string') {\n      return res.status(400).json({ error: 'product_id is required' });\n    }\n\n    const product = await stripe.products.retrieve(product_id);\n    res.json(product);\n  } catch (error) {\n    console.error('Error fetching product:', error);\n    res.status(500).json({ error: 'Internal server error', details: (error as Error).message });\n  }\n});\n\nexport { router as productsRouter };\n\n"
    },
    {
      "target": "routes/stripe/subscriptions.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\nconst router = express.Router();\nconst stripe = getStripe();\n\n\nrouter.get('/', async (req, res) => {\n  try {\n    const { subscription_id } = req.query;\n\n    if (!subscription_id || typeof subscription_id !== 'string') {\n      return res.status(400).json({ error: 'subscription_id is required' });\n    }\n\n    const subscription = await stripe.subscriptions.retrieve(subscription_id);\n    res.json(subscription);\n  } catch (error) {\n    console.error('Error fetching subscription:', error);\n    res.status(500).json({ error: 'Internal server error', details: (error as Error).message });\n  }\n});\n\n\nrouter.get('/list', async (req, res) => {\n  try {\n    const { customer_id, limit, starting_after } = req.query;\n\n    if (!customer_id || typeof customer_id !== 'string') {\n      return res.status(400).json({ error: 'customer_id is required' });\n    }\n\n    const params: Stripe.SubscriptionListParams = {\n      customer: customer_id,\n    };\n\n    if (limit && typeof limit === 'string') {\n      const parsed = parseInt(limit, 10);\n      if (!isNaN(parsed)) params.limit = parsed;\n    }\n\n    if (starting_after && typeof starting_after === 'string') {\n      params.starting_after = starting_after;\n    }\n\n    const subscriptions = await stripe.subscriptions.list(params);\n    res.json(subscriptions.data); // return only the subscriptions array\n  } catch (error) {\n    console.error('Error fetching subscriptions list:', error);\n    res.status(500).json({ error: 'Internal server error', details: (error as Error).message });\n  }\n});\n\nexport { router as subscriptionsRouter };\n"
    },
    {
      "target": "routes/stripe/webhook.ts",
      "type": "template",
      "content": "import express from 'express';\nimport Stripe from 'stripe';\nimport { getStripe } from '../../lib/stripe';\n\nconst router = express.Router();\nconst stripe = getStripe();\n\n\nrouter.post('/', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'] as string | undefined;\n  if (!sig) {\n    return res.status(400).json({ error: 'Missing Stripe signature' });\n  }\n\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;\n  let event: Stripe.Event;\n\n  try {\n    event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n  } catch (err) {\n    console.error('Webhook signature verification failed:', err);\n    return res.status(400).json({ error: 'Webhook verification failed' });\n  }\n\n  try {\n    switch (event.type) {\n      \n      case 'customer.subscription.created':\n      case 'customer.subscription.updated':\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object as Stripe.Subscription;\n        console.log('Subscription event:', event.type, subscription.id);\n        break;\n      }\n\n      \n      case 'payment_intent.succeeded': {\n        const paymentIntent = event.data.object as Stripe.PaymentIntent;\n        console.log('Payment succeeded:', paymentIntent.id, paymentIntent.amount);\n        break;\n      }\n\n      case 'payment_intent.payment_failed': {\n        const paymentIntent = event.data.object as Stripe.PaymentIntent;\n        console.log('Payment failed:', paymentIntent.id, paymentIntent.last_payment_error);\n        break;\n      }\n\n      case 'charge.refunded': {\n        const charge = event.data.object as Stripe.Charge;\n        console.log('Charge refunded:', charge.id, charge.amount_refunded);\n        break;\n      }\n\n      default:\n        console.log('Unhandled event type:', event.type);\n        break;\n    }\n\n    res.status(200).json({ message: 'Webhook processed successfully' });\n  } catch (err) {\n    console.error('Error handling webhook event:', err);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\nexport { router as webhookRouter };\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "# DodoPayments Configuration\nDODO_PAYMENTS_API_KEY=your_api_key_here\nDODO_PAYMENTS_ENVIRONMENT=test_mode\nDODO_PAYMENTS_WEBHOOK_KEY=your_webhook_key_here\n\n# Server Configuration\nPORT=3000\nNODE_ENV=development\n\nSTRIPE_SECRET_KEY=\"your_secret_key_here\"\nSTRIPE_SECRET_KEY=sk_test_12345...\nSTRIPE_WEBHOOK_SECRET=whsec_12345\n"
    }
  ],
  "dependencies": [
    "stripe",
    "express",
    "zod",
    "@types/express"
  ]
}