{
  "name": "nextjs-stripe",
  "description": "Stripe template for NextJS",
  "framework": "nextjs",
  "files": [
    {
      "target": "lib/stripe.ts",
      "type": "template",
      "content": "import Stripe from 'stripe';\n\nlet _stripe: Stripe | null = null;\nexport const getStripe = (): Stripe => {\n  if (!_stripe) {\n    _stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {\n      \n    });\n  }\n  return _stripe;\n};"
    },
    {
      "target": "app/api/(stripe)/checkout/route.ts",
      "type": "template",
      "content": "import { z } from \"zod\";\nimport {NextRequest, NextResponse} from \"next/server\";\nimport { getStripe } from \"@/lib/stripe\";\n\n\nconst productCartItemSchema = z.object({\n    name: z.string().min(1),\n    quantity: z.number().int().min(1),\n    amount: z.number().int().min(1),\n});\n\nconst stripe = getStripe();\n\nconst customerSchema = z.object({\n    email: z.string().email(),\n    name: z.string().min(1)\n});\n\nconst checkoutSessionSchema = z.object({\n    productCart: z.array(productCartItemSchema).min(1),\n    customer: customerSchema,\n    return_url: z.string().url,\n    metadata: z.record(z.string(), z.string()).optional()\n\n})\n\n\nexport async function POST(req: NextRequest) {\n    try{\n        const body = await req.json();\n        const validation = checkoutSessionSchema.safeParse(body);\n\n        if(!validation.success) {\n            return NextResponse.json({\n                error: \"Validation failed\",\n                details: validation.error.issues.map(issue => ({\n                    field: issue.path.join(\".\"),\n                    message: issue.message\n                }))\n\n            }\n            , {status: 400}\n            )\n        }\n\n        const {productCart, customer, return_url, metadata} = validation.data;\n\n        const session = await stripe?.checkout.sessions.create({\n            payment_method_types: [\"card\"],\n            line_items: productCart.map(item => ({\n                price_data: {\n                    currency: \"usd\",\n                    product_data: {name: item.name},\n                    unit_amount: item.amount\n                },\n                quantity: item.quantity\n            })),\n            mode: \"payment\",\n            customer_email: customer.email,\n            success_url: `${return_url}?status=success&session_id={CHECKOUT_SESSION_ID}`,\n            cancel_url: `${return_url}?status=cancelled`,\n            metadata\n        });\n        return NextResponse.json({url: session.url})\n    } catch (error) {\n        console.error(\"Stripe checkout error: \", error);\n        return NextResponse.json({error: \"Internal server error\"}, {status: 500})\n\n    }\n\n}   "
    },
    {
      "target": "app/api/(stripe)/customer/payments/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\n\nconst stripe = getStripe();\n\nconst paymentQuerySchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const customer_id = url.searchParams.get(\"customer_id\");\n\n    const validationResult = paymentQuerySchema.safeParse({ customer_id });\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { error: validationResult.error.issues[0].message },\n        { status: 400 }\n      );\n    }\n\n    const validatedParams = validationResult.data;\n\n    \n    const paymentIntents = await stripe.paymentIntents.list({\n      customer: validatedParams.customer_id,\n      limit: 10\n    });\n\n    return NextResponse.json(paymentIntents.data);\n  } catch (error) {\n    console.error(\"Error fetching customer payments:\", error);\n    return NextResponse.json(\n      { error: \"Failed to fetch customer payments\" },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/customer/route.ts",
      "type": "template",
      "content": "\nimport { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst stripe = getStripe();\n\nconst customerIdSchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst createCustomerSchema = z.object({\n    email: z.string().email(\"Invalid email format\"),\n    name: z.string().min(1, \"Name is required\"),\n    phone_number: z.string().optional().nullable(),\n});\n\nconst updateCustomerSchema = z.object({\n    name: z.string().optional().nullable(),\n    phone_number: z.string().optional().nullable(),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const queryParams = {\n            customer_id: url.searchParams.get('customer_id'),\n        };\n        const validationResult = customerIdSchema.safeParse(queryParams);\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { customer_id } = validationResult.data;\n        const customer = await stripe.customers.retrieve(customer_id);\n        return NextResponse.json(customer);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n           return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n\n        console.error('Error retrieving customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to retrieve customer' },\n            { status: 500 }\n        );\n    }\n}\n\nexport async function POST(request: Request) {\n    try {\n        const body = await request.json();\n\n        const validationResult = createCustomerSchema.safeParse(body);\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const customer = await stripe.customers.create({\n             email: validationResult.data.email,\n             name: validationResult.data.name,\n             phone: validationResult.data.phone_number ?? undefined,\n        });\n        return NextResponse.json(customer);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n        return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n\n        console.error('Error creating customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to create customer' },\n            { status: 500 }\n        );\n    }\n}\n\nexport async function PUT(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const customer_id = url.searchParams.get('customer_id');\n        const body = await request.json();\n\n        const customerIdValidation = customerIdSchema.safeParse({ customer_id });\n        if (!customerIdValidation.success) {\n            return NextResponse.json(\n                { error: customerIdValidation.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const updateValidation = updateCustomerSchema.safeParse(body);\n        if (!updateValidation.success) {\n            return NextResponse.json(\n                { error: updateValidation.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { customer_id: validCustomerId } = customerIdValidation.data;\n\n        const updateData = Object.fromEntries(\n            Object.entries(updateValidation.data).filter(([, v]) => v !== null)\n        );\n        const customer = await stripe.customers.update(validCustomerId, updateData);\n        return NextResponse.json(customer);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n            return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n\n        console.error('Error updating customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to update customer' },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/(stripe)/customer/subscription/route.ts",
      "type": "template",
      "content": "\nimport { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst subscriptionQuerySchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst stripe = getStripe();\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const customer_id = url.searchParams.get('customer_id');\n\n        const validationResult = subscriptionQuerySchema.safeParse({ customer_id });\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const subscriptions = await stripe.subscriptions.list({\n            customer: validationResult.data.customer_id,\n            status: 'all',\n            expand: [\"data.default_payment_method\"]\n        });\n\n        return NextResponse.json(subscriptions);\n    } catch (error) {\n        console.error('Error fetching subscriptions:', error);\n        return NextResponse.json({ error: 'Failed to fetch subscriptions' }, { status: 500 });\n    }\n}"
    },
    {
      "target": "app/api/(stripe)/product/route.ts",
      "type": "template",
      "content": "\nimport { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst stripe = getStripe();\n\nconst productIdSchema = z.object({\n    product_id: z.string().min(1, \"Product ID is required\"),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const queryParams = {\n            product_id: url.searchParams.get('product_id'),\n        };\n        const validationResult = productIdSchema.safeParse(queryParams);\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { product_id } = validationResult.data;\n\n        const product = await stripe.products.retrieve(product_id);\n        return NextResponse.json(product);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n        return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n        console.error('Error retrieving product:', error);\n        return NextResponse.json(\n            { error: 'Failed to retrieve product' },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/(stripe)/products/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\n\nconst stripe = getStripe();\n\nexport async function GET() {\n    try {\n        const products = await stripe.products.list();\n        return NextResponse.json(products);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n        return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n        console.error('Error fetching products:', error);\n        return NextResponse.json(\n            { error: \"Failed to fetch products\" },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/(stripe)/webhook/route.ts",
      "type": "template",
      "content": "import { headers } from \"next/headers\";\nimport { getStripe } from \"@/lib/stripe\";\n\nconst stripe = getStripe();\n\nexport async function POST(req: Request) {\n  const body = await req.text();\n  const sig = (await headers()).get(\"stripe-signature\");\n\n  let event;\n  try {\n    event = stripe.webhooks.constructEvent(\n      body,\n      sig!,\n      process.env.STRIPE_WEBHOOK_SECRET!\n    );\n  } catch (err) {\n    console.error(\"Webhook verification failed:\", err);\n    return Response.json({ error: \"Invalid signature\" }, { status: 400 });\n  }\n\n  try {\n    switch (event.type) {\n      case \"customer.subscription.created\":\n      case \"customer.subscription.updated\":\n      case \"customer.subscription.deleted\": {\n        const subscription = event.data.object;\n        console.log(\"Subscription event:\", subscription.id, event.type);\n        break;\n      }\n\n      case \"payment_intent.succeeded\": {\n        const paymentIntent = event.data.object;\n        console.log(\"Payment succeeded:\", paymentIntent.id);\n        break;\n      }\n\n      case \"checkout.session.completed\": {\n        const session = event.data.object;\n        console.log(\"Checkout completed:\", session.id);\n        break;\n      }\n\n      default:\n        console.log(`Unhandled event type ${event.type}`);\n    }\n\n    return Response.json({ received: true }, { status: 200 });\n  } catch (error) {\n    console.error(\"Error handling event:\", error);\n    return Response.json({ error: \"Webhook handling failed\" }, { status: 500 });\n  }\n}\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "DODO_PAYMENTS_API_KEY=your-api-key\nDODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret\nDODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success\nDODO_PAYMENTS_ENVIRONMENT=\"test\"or\"live\"\n\nSTRIPE_SECRET_KEY=your=stripe-secret-key"
    }
  ],
  "dependencies": [
    "stripe",
    "react",
    "zod"
  ]
}